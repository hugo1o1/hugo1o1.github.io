import{_ as e,c as a,o as n,a as t}from"./app.8538473e.js";const f='{"title":"npm vs yarn vs pnpm","description":"","frontmatter":{},"headers":[{"level":2,"title":"Overview of package managers","slug":"overview-of-package-managers"},{"level":2,"title":"Features of npm, Yarn, and pnpm","slug":"features-of-npm-yarn-and-pnpm"},{"level":2,"title":"Package manager comparison","slug":"package-manager-comparison"}],"relativePath":"JavaScript/npm-vs-yarn-pnpm.md","lastUpdated":1646059216000}',s={},o=t('<h1 id="npm-vs-yarn-vs-pnpm" tabindex="-1">npm vs yarn vs pnpm <a class="header-anchor" href="#npm-vs-yarn-vs-pnpm" aria-hidden="true">#</a></h1><p>In modern application development, we don\u2019t write everything from scratch. Instead, we prefer to use existing open-source packages. Each of these packages has its own maintainers and community. So, using a package in our projects gives us some advantages like faster development, access to new, regular updates, and better security than custom-created script.</p><p>It\u2019s common that one package depends on many other packages to work correctly. Similarly, the other packages may also depend on something like lodash, but lodash itself depends on several packages as well. In other words, the nested dependencies can sometimes become so complex that they are unable to handle dependency management manually.</p><p>Here\u2019s when a package manager is extremely useful. Package managers are tools that automatically handle the dependencies of a project.</p><p>For example, a package manager can install new \u2014 or update existing \u2014 packages with a single command. Because everything is automated, so there\u2019s no chance for human error. As JavaScript developers, we have access to several package managers. But, in this guide, we\u2019ll compare the three most popular ones: npm,Yarn,pnpm</p><h2 id="overview-of-package-managers" tabindex="-1">Overview of package managers <a class="header-anchor" href="#overview-of-package-managers" aria-hidden="true">#</a></h2><p>npm was the first package manager to introduce the concepts of registry protocol and packaging standards. It was released back in 2010 and officially adopted by the Node.js team shortly afterward, which was the turning point for npm.</p><p>After the massive success of Node.js, npm also received traction from the developer\u2019s community. It offers an online registry for JavaScript packages as well as a command-line tool that works with the registry to install and update dependencies.</p><p>But there are few drawbacks of npm that triggered the development of Yarn and pnpm. For example, npm is significantly slower than its counterparts. It also has a history of serious security vulnerabilities.</p><p>So, big tech companies like Facebook and Google were hesitant to keep using npm. In turn, they joined efforts to develop a better version of npm and call it Yarn. Meanwhile, Ukrainian developer Zoltan Kochan developed pnpm.</p><h2 id="features-of-npm-yarn-and-pnpm" tabindex="-1">Features of npm, Yarn, and pnpm <a class="header-anchor" href="#features-of-npm-yarn-and-pnpm" aria-hidden="true">#</a></h2><p>All of these package managers are open-source, meaning you have full access to check the inner workings of each one. Sometimes this is even a requirement in enterprise-level application development.</p><h4 id="benefits-of-npm" tabindex="-1">Benefits of npm: <a class="header-anchor" href="#benefits-of-npm" aria-hidden="true">#</a></h4><p>Automatically generates a package-lock.json file. It\u2019s useful to commit to a version control system. This way, other developers can easily install the dependencies on their local machines Manage local or global dependencies with ease npm is well equipped to handle multiple versions of dependencies It has an official registry that has more packages than pypi, rubygems, or packagist</p><h4 id="benefits-of-yarn" tabindex="-1">Benefits of Yarn: <a class="header-anchor" href="#benefits-of-yarn" aria-hidden="true">#</a></h4><p>Yarn fixes many issues that appear in a Monorepo. For example, if you are maintaining multiple packages under the same repository and they all have a separate package.json file, you can update all packages easily with Yarn, thanks to its concept of workspaces that can install dependencies of all packages in a repository, all in one go. With npm, you\u2019d need to run the npm install command manually within each package folder. Yarn makes use of an offline cache mechanism, meaning that when you install a package for the first time, Yarn adds it to a cache folder under ~/.yarn-cache. So, the next time you need this package, Yarn will retrieve it from the local cache instead of making an HTTP request to the server. This small enhancement significantly boosts the performance of Yarn compared to npm Yarn also makes use of a lock file called yarn.lock, so your projects will work correctly for all teammates. This concept is also referred to as a deterministic install algorithm It\u2019s packed with a built-in license checker that can be handy in different scenarios when you\u2019re developing applications Unlike npm, Yarn uses an approach called parallel downloads. It enables Yarn to utilize more resources to speed up the build process It can automatically retry the HTTP request in case of failure. This feature is particularly useful when you are facing temporary internet issues</p><h4 id="benefits-of-pnpm" tabindex="-1">Benefits of pnpm: <a class="header-anchor" href="#benefits-of-pnpm" aria-hidden="true">#</a></h4><p>It\u2019s compatible with npm but also offers significantly better disk space usage and speed pnpm installs all packages on a single location and then uses symlinks to reference them. It introduces a completely new concept called a content-addressable storage system that enables pnpm to detect the difference between files. In turn, it doesn\u2019t duplicate unchanged files in two different versions of a package Its latest version, 5.8.0, introduces a new Yarn-bash-like setting called shell-emulator, a cross-platform shell environment pnpm has a strict access control mechanism, meaning that a package can only access the dependencies that are defined in its package.json file</p><h2 id="package-manager-comparison" tabindex="-1">Package manager comparison <a class="header-anchor" href="#package-manager-comparison" aria-hidden="true">#</a></h2><p>*#### Ease of use npm, Yarn, and pnpm offer almost identical commands for their various operations, and they are all easy to use. Here\u2019s an example of their commonly used commands:</p><table><thead><tr><th>npm</th><th>Yarn</th><th>pnpm</th></tr></thead><tbody><tr><td>npm install</td><td>yarn install</td><td>pnpm install</td></tr><tr><td>npm update</td><td>yarn upgrade</td><td>pnpm update</td></tr></tbody></table><h4 id="speed" tabindex="-1">speed <a class="header-anchor" href="#speed" aria-hidden="true">#</a></h4><p>There\u2019s no match to pnpm when it comes to the speed and performance of these package managers. According to a benchmark of different use cases, pnpm has shown performance speeds up to 3x faster than npm.</p><p>The speeds of Yarn and npm are comparable. In some cases, Yarn has a significant advantage over npm, but there are scenarios where npm is a more suitable choice. For example, if we perform an install operation by just using node_modules and skip cache and lock file functionality, then npm could offer 5x better speed. Similarly, if we use all three functionalities, then Yarn could boost its performance and becomes 11x faster than npm.</p><h4 id="security" tabindex="-1">Security <a class="header-anchor" href="#security" aria-hidden="true">#</a></h4><p>The major advantage of Yarn over npm is that it verifies the integrity of each package using checksums. The verification process is done before executing any code from the package, so it discards any chances of package hijacking vulnerability.</p><p>On the other hand, npm is a bit more forgiving when it comes to working with bad packages. It is still evolving in order to offer the best practices for security. But, npm generally has a bad reputation in terms of security.</p><p>In the past, there were some security vulnerabilities in npm that directly affected many projects. For example, in npm version 5.7.0, when you execute sudo npm command on a Linux-based operating system (OS), there was a possibility to change the ownership of system files, rendering the OS unusable.</p><p>Similarly, another incident of stealing bitcoins happened in 2018. Basically, the popular Node.js package EventStream added a malicious dependency flatmap-stream in its version 3.3.6. This malicious package was packed with an encrypted payload that tries to steal bitcoins from the developer\u2019s machine.</p><p>pnpm combines the positive attributes of both npm and Yarn to provide even better security. It also implements a strict access control mechanism that binds a package to only use its own dependencies that are defined in its package.json file.</p><h4 id="stability" tabindex="-1">Stability <a class="header-anchor" href="#stability" aria-hidden="true">#</a></h4><p>npm, Yarn, and pnpm have gone through several phases over the past few years. Over time, their codebase has matured because they\u2019ve received tons of contributions from the open-source community.</p><p>And, with the passage of time, new concepts and ideas appear that could introduce breaking changes. At the time of writing this guide, all these package managers are in good shape and you can use them in your projects without any issues.</p><p>Yarn is backed by Facebook and Google, npm is backed by Microsoft and Node.js, and pnpm is mostly developed by an individual, although it now has 75+ contributors \u2014 so you can depend on these package managers to create your next project.</p><h4 id="support-for-monorepos" tabindex="-1">Support for monorepos <a class="header-anchor" href="#support-for-monorepos" aria-hidden="true">#</a></h4><p><strong>Monorepos</strong> are mostly preferred by large tech companies to store and manage their massive codebases. npm was only designed to manage individual projects. As of now, it doesn\u2019t have any functionality to support monorepos. But both Yarn and pnpm have complete support for monorepos, thanks to their concept of workspaces.</p><h4 id="deterministic-\u2014-the-lock-file" tabindex="-1">Deterministic \u2014 the lock file <a class="header-anchor" href="#deterministic-\u2014-the-lock-file" aria-hidden="true">#</a></h4><p>All three package managers are packed with the functionality of the lock file. It allows different developers to install the exact same copy of the project. npm uses a package-lock.json file, Yarn uses yarn.lock, and pnpm uses pnpm-lock.yaml.</p><h4 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-hidden="true">#</a></h4><p>If you are searching for a solution that gives you better speed and efficient memory usage, you should strongly consider using pnpm.</p><p>If you are handling monorepos, you can use pnpm or Yarn to do so. However, keep in mind that Yarn sends usage data to Facebook, which may not make Yarn a suitable choice in some scenarios.</p><p>Yarn also doesn\u2019t support version 5 of Node.js. In this regard, npm is a preferred option for Node.js-based projects because it is recommended by the Node.js team. These days, Node.js comes with npm by default.</p><p>With npm, you should consider its history with security issues, which triggered the development of Yarn, which was also created to solve many issuers that were present in npm. So, if you\u2019re concerned with security of your projects, consider using Yarn instead of npm.</p>',43),r=[o];function i(p,c,d,l,h,m){return n(),a("div",null,r)}var g=e(s,[["render",i]]);export{f as __pageData,g as default};
